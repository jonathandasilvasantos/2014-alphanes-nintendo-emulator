package mapper

import (
	"log"
)

// MMC3 specific constants
const (
	MMC3_CHR_MODE_2_2_4 = 0x00
	MMC3_CHR_MODE_4_2_2 = 0x80
	MMC3_PRG_MODE_SWAP  = 0x40
	MMC3_PRG_MODE_FIXED = 0x00
)

// MMC3State holds the internal state of the MMC3 mapper
type MMC3State struct {
	Command      byte   // Current command register
	PRGMode      byte   // PRG ROM bank mode (swap or fixed)
	CHRMode      byte   // CHR ROM bank mode (2-2-4 or 4-2-2)
	PRGBank      [4]byte // PRG ROM bank selections
	CHRBank      [8]byte // CHR ROM bank selections
	Mirroring    byte   // Mirroring mode (0: vertical, 1: horizontal)
	PRGRAMEnable  bool   // PRG RAM enable/disable flag
	IRQEnable    bool   // IRQ enable flag
	IRQCounter   byte   // IRQ scanline counter
	IRQLatch     byte   // IRQ reload value
	IRQReload    bool   // Flag to indicate reload IRQ counter
	A12Inversion  bool   // For MMC6 only
	LastA12State  bool   // Last state of PPU A12
	CurrentCycleCount uint64 // For debugging (remove if not needed)
}

// MMC3 represents the MMC3 mapper (Mapper 4).
type MMC3 struct {
	state MMC3State
	cart  MapperAccessor
	cpu   CPUAccessor // Add a reference to the CPU (for IRQ signaling)
}

// CPUAccessor interface for the MMC3 mapper to communicate with the CPU (for IRQs).
type CPUAccessor interface {
	SetIRQ(bool)
}

// SetCPU sets the CPU reference for the mapper.
func (m *MMC3) SetCPU(cpu CPUAccessor) {
    m.cpu = cpu
}

// Initialize initializes the MMC3 mapper.
func (m *MMC3) Initialize(cart MapperAccessor) {
	m.cart = cart
	m.reset()
	log.Printf("MMC3 Mapper Initialized\n")
}

// reset resets the MMC3 mapper to its default state.
func (m *MMC3) reset() {
	m.state.Command = 0
	m.state.PRGMode = MMC3_PRG_MODE_FIXED // Default: fixed $C000-$DFFF to second-to-last bank
	m.state.CHRMode = MMC3_CHR_MODE_2_2_4 // Default: 2KB+2KB+1KB+1KB+1KB+1KB
	m.state.PRGBank[0] = 0
	m.state.PRGBank[1] = 0
	m.state.PRGBank[2] = 0
	m.state.PRGBank[3] = 0 // Fixed to the last bank, updated during mapping
	m.state.CHRBank[0] = 0
	m.state.CHRBank[1] = 0
	m.state.CHRBank[2] = 0
	m.state.CHRBank[3] = 0
	m.state.CHRBank[4] = 0
	m.state.CHRBank[5] = 0
	m.state.CHRBank[6] = 0
	m.state.CHRBank[7] = 0
	m.state.Mirroring = 0
	m.state.PRGRAMEnable = false
	m.state.IRQEnable = false
	m.state.IRQCounter = 0
	m.state.IRQLatch = 0
	m.state.IRQReload = false
	m.state.A12Inversion = false // Default, MMC6 should change it accordingly
	m.state.LastA12State = false
	m.state.CurrentCycleCount = 0
	m.updateBankMapping()
	log.Printf("MMC3 Mapper Reset\n")
}

// MapCPU maps a CPU address to a PRG ROM/RAM address.
func (m *MMC3) MapCPU(addr uint16) (bool, uint16) {
	m.state.CurrentCycleCount++

	switch {
	case addr >= 0x6000 && addr <= 0x7FFF: // PRG RAM
		if m.state.PRGRAMEnable && m.cart.HasSRAM() {
			return false, addr - 0x6000 // 8KB PRG RAM
		}
		log.Printf("Attempted to access disabled or non-existent PRG RAM at %04X", addr)
		return false, 0 // PRG RAM disabled or not present

	case addr >= 0x8000: // PRG ROM
		var bankIndex int
		switch {
		case addr >= 0x8000 && addr <= 0x9FFF:
			if m.state.PRGMode == MMC3_PRG_MODE_FIXED {
				// $8000-$9FFF is switchable bank 0
				bankIndex = int(m.state.PRGBank[0])
			} else {
				// $8000-$9FFF is fixed to second to last bank
				bankIndex = int(m.cart.GetPRGSize()/8192 - 2) // Second to last bank
			}
		case addr >= 0xA000 && addr <= 0xBFFF:
			// $A000-$BFFF is always switchable bank 1
			bankIndex = int(m.state.PRGBank[1])
		case addr >= 0xC000 && addr <= 0xDFFF:
			if m.state.PRGMode == MMC3_PRG_MODE_FIXED {
				// $C000-$DFFF is fixed to second to last bank
				bankIndex = int(m.cart.GetPRGSize()/8192 - 2) // Second to last bank
			} else {
				// $C000-$DFFF is switchable bank 2
				bankIndex = int(m.state.PRGBank[2])
			}
		case addr >= 0xE000 && addr <= 0xFFFF:
			// $E000-$FFFF is fixed to the last bank
			bankIndex = int(m.cart.GetPRGSize()/8192 - 1) // Last bank
		}

		// Wrap bank numbers to fit within the available PRG ROM
		bankIndex = bankIndex % int(m.cart.GetPRGSize()/8192)

		// Calculate the final address in PRG ROM
		finalAddr := uint16(bankIndex*8192) + (addr & 0x1FFF)
		return true, finalAddr

	default:
		return false, addr // Unmapped addresses
	}
}

// MapPPU maps a PPU address to a CHR ROM/RAM address.
func (m *MMC3) MapPPU(addr uint16) uint16 {
	
	// Track A12 for IRQ
    currentA12State := addr&0x1000 != 0
    if currentA12State && !m.state.LastA12State {
        // A12 rising edge detected
        m.Clock(1) // Trigger a clock cycle on the mapper
    }
    m.state.LastA12State = currentA12State
	
	
	if addr >= 0x3F00 && addr <= 0x3FFF {
        // Handle mirroring and special cases for palette RAM
        addr = 0x3F00 + (addr % 0x20)
        if addr == 0x3F10 || addr == 0x3F14 || addr == 0x3F18 || addr == 0x3F1C {
            addr -= 0x10
        }
        return addr
    }

    if addr < 0x2000 { // CHR ROM/RAM, handled by updateCHRBanks
        bankIndex := addr / 0x400
        bankOffset := addr % 0x400
		
		var chrBankIndices []int
		
        
        if m.state.CHRMode == MMC3_CHR_MODE_2_2_4 {
			// 2-2-4 mode
			chrBankIndices = []int{
				int(m.state.CHRBank[0] & 0xFE), // R0: Ignore lowest bit in this mode
				int(m.state.CHRBank[0] & 0xFE) + 1,
				int(m.state.CHRBank[1] & 0xFE), // R1: Ignore lowest bit in this mode
				int(m.state.CHRBank[1] & 0xFE) + 1,
				int(m.state.CHRBank[2]), // R2
				int(m.state.CHRBank[3]), // R3
				int(m.state.CHRBank[4]), // R4
				int(m.state.CHRBank[5]), // R5
			}
		} else {
			// 4-2-2 mode
			chrBankIndices = []int{
				int(m.state.CHRBank[0] & 0xFC), // R0: Ignore lowest 2 bits in this mode
				int(m.state.CHRBank[0] & 0xFC) + 1,
				int(m.state.CHRBank[0] & 0xFC) + 2,
				int(m.state.CHRBank[0] & 0xFC) + 3,
				int(m.state.CHRBank[1] & 0xFE), // R1: Ignore lowest bit in this mode
				int(m.state.CHRBank[1] & 0xFE) + 1,
				int(m.state.CHRBank[2] & 0xFE), // R2: Ignore lowest bit in this mode
				int(m.state.CHRBank[2] & 0xFE) + 1,
			}
		}

        // Wrap bank numbers to fit within the available CHR ROM/RAM
        chrBankIndex := chrBankIndices[bankIndex] % int(m.cart.GetCHRSize()/1024)

        finalAddr := uint16(chrBankIndex*1024) + bankOffset
		
		//fmt.Printf("addr: %04X bankIndex: %d chrBankIndex: %d offset: %04X final: %04X\n", addr, bankIndex, chrBankIndex, bankOffset, finalAddr)
        return finalAddr
    }

    // Nametable mirroring
    addr = addr & 0x3FFF
    if addr >= 0x3000 && addr < 0x3F00 {
        addr -= 0x1000
    }

    if addr >= 0x2000 && addr < 0x3000 {
        addr = addr - 0x2000
        table := addr / 0x400
        offset := addr % 0x400

        switch m.state.Mirroring {
        case 0: // Vertical
            if table == 1 || table == 3 {
                addr = 0x2400 + offset
            } else {
                addr = 0x2000 + offset
            }
        case 1: // Horizontal
            if table >= 2 {
                addr = 0x2400 + offset
            } else {
                addr = 0x2000 + offset
            }
        }
    }

    return addr
}

// Write handles writes to the MMC3 mapper's registers.
func (m *MMC3) Write(addr uint16, value byte) {
    
	log.Printf("MMC3 Write: Addr=%04X, Value=%02X\n", addr, value)
	
    switch {
	case addr >= 0x8000 && addr <= 0x9FFF:
		if addr%2 == 0 {
			// Command register ($8000, $8002, $8004, etc.)
			m.state.Command = value
			m.state.PRGMode = value & MMC3_PRG_MODE_SWAP
			m.state.CHRMode = value & MMC3_CHR_MODE_4_2_2
		} else {
			// Data register ($8001, $8003, $8005, etc.)
			bankIndex := m.state.Command & 0x07
			
			
			switch {
			case bankIndex == 0:
				// CHR ROM bank selection in 2KB chunks (adjusted for 2-2-4 mode)
				m.state.CHRBank[0] = value 
			case bankIndex == 1:
				m.state.CHRBank[1] = value 
			case bankIndex == 2:
				m.state.CHRBank[2] = value 
			case bankIndex == 3:
				m.state.CHRBank[3] = value 
			case bankIndex == 4:
				m.state.CHRBank[4] = value 
			case bankIndex == 5:
				m.state.CHRBank[5] = value 
			case bankIndex == 6:
				// PRG ROM bank selection (first switchable bank)
				m.state.PRGBank[0] = value & 0x3F // Only lower 6 bits are used
			case bankIndex == 7:
				// PRG ROM bank selection (second switchable bank)
				m.state.PRGBank[1] = value & 0x3F // Only lower 6 bits are used
			}
		}

	case addr >= 0xA000 && addr <= 0xBFFF:
		if addr%2 == 0 {
			// Mirroring register ($A000, $A002, etc.)
			m.state.Mirroring = value & 0x01
		} else {
			// PRG RAM protect register ($A001, $A003, etc.)
			m.state.PRGRAMEnable = (value&0x80 == 0) && (value&0x40 != 0)
		}

	case addr >= 0xC000 && addr <= 0xDFFF:
		if addr%2 == 0 {
			// IRQ latch register ($C000, $C002, etc.)
			m.state.IRQLatch = value
		} else {
			// IRQ reload register ($C001, $C003, etc.)
			m.state.IRQReload = true
		}

	case addr >= 0xE000 && addr <= 0xFFFF:
		if addr%2 == 0 {
			// IRQ disable register ($E000, $E002, etc.)
			m.state.IRQEnable = false
			m.cpu.SetIRQ(false) // Clear any pending IRQ when disabling
		} else {
			// IRQ enable register ($E001, $E003, etc.)
			m.state.IRQEnable = true
		}
	}

	// Update bank mapping after each write
	m.updateBankMapping()
}

// updateBankMapping updates the PRG and CHR ROM bank mapping based on the current MMC3 state.
func (m *MMC3) updateBankMapping() {
	numPRGBanks := m.cart.GetPRGSize() / 8192
	numCHRBanks := m.cart.GetCHRSize() / 1024

	// Update PRG ROM mapping
	m.state.PRGBank[3] = byte(numPRGBanks - 1) // Last bank is always fixed
	if m.state.PRGMode == MMC3_PRG_MODE_FIXED {
		m.state.PRGBank[2] = byte(numPRGBanks - 2) // Second to last bank is fixed
	}

	// Update CHR ROM mapping (CHR RAM is handled in MapPPU)
    if m.cart.GetCHRSize() == 0 {
        if m.cart.GetCHRRAMSize() != 8192 {
            m.cart.SetCHRRAMSize(8192) // Ensure 8KB CHR RAM is allocated
            log.Printf("Allocated 8KB CHR RAM")
        }
        // Nothing to copy, just return
    } else {
	// Wrap bank numbers to fit within the available ROM sizes
	for i := 0; i < 4; i++ {
		m.state.PRGBank[i] = m.state.PRGBank[i] % byte(numPRGBanks)
	}
	for i := 0; i < 8; i++ {
		m.state.CHRBank[i] = m.state.CHRBank[i] % byte(numCHRBanks)
	}
	}

	// Log the updated bank mapping
	log.Printf("MMC3 Bank Mapping Updated: PRGMode=%02X, CHRMode=%02X, PRGBanks=[%02X, %02X, %02X, %02X], CHRBanks=[%02X, %02X, %02X, %02X, %02X, %02X, %02X, %02X]",
		m.state.PRGMode, m.state.CHRMode, m.state.PRGBank[0], m.state.PRGBank[1], m.state.PRGBank[2], m.state.PRGBank[3],
		m.state.CHRBank[0], m.state.CHRBank[1], m.state.CHRBank[2], m.state.CHRBank[3], m.state.CHRBank[4], m.state.CHRBank[5], m.state.CHRBank[6], m.state.CHRBank[7])
}

// Clock is called by the PPU on every PPU cycle.
func (m *MMC3) Clock(cycles uint64) {
    
    for i := uint64(0); i < cycles; i++ {
        if m.state.IRQReload {
            m.state.IRQCounter = m.state.IRQLatch
            m.state.IRQReload = false
        } else if m.state.IRQCounter > 0 {
            m.state.IRQCounter--
        } else {
			m.state.IRQCounter = m.state.IRQLatch
		}

        if m.state.IRQCounter == 0 && m.state.IRQEnable {
            // Signal IRQ to CPU
            if m.cpu != nil {
				
                m.cpu.SetIRQ(true)
            }
        }
    }
}
